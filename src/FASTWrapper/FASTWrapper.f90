!**********************************************************************************************************************************
!> ## FASTWrapper
!! The FASTWrapper and FASTWrapper_Types modules make up a template for creating user-defined calculations in the FAST Modularization
!! Framework. FASTWrappers_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! FASTWrapper_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2012-2013, 2015-2016  National Renewable Energy Laboratory
!!
!!    This file is part of FASTWrapper.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE FASTWrapper

   USE FASTWrapper_Types
   USE NWTC_Library
   USE FAST_Subs


   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER  :: FWrap_Ver = ProgDesc( 'FASTWrapper', 'v1.00.00', '2-Dec-2016' ) !< module date/version information

   REAL(DbKi),     PARAMETER  :: t_initial = 0.0_DbKi                    ! Initial time

   ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: FWrap_Init                           !  Initialization routine
   PUBLIC :: FWrap_End                            !  Ending routine (includes clean up)

   PUBLIC :: FWrap_UpdateStates                   !  Loose coupling routine for solving for constraint states, integrating
                                                  !    continuous states, and updating discrete states
   PUBLIC :: FWrap_CalcOutput                     !  Routine for computing outputs


CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.   
SUBROUTINE FWrap_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(FWrap_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(FWrap_InputType),           INTENT(  OUT)  :: u           !< An initial guess for the input; input mesh must be defined
   TYPE(FWrap_ParameterType),       INTENT(  OUT)  :: p           !< Parameters
   TYPE(FWrap_ContinuousStateType), INTENT(  OUT)  :: x           !< Initial continuous states
   TYPE(FWrap_DiscreteStateType),   INTENT(  OUT)  :: xd          !< Initial discrete states
   TYPE(FWrap_ConstraintStateType), INTENT(  OUT)  :: z           !< Initial guess of the constraint states
   TYPE(FWrap_OtherStateType),      INTENT(  OUT)  :: OtherState  !< Initial other states (logical, etc)
   TYPE(FWrap_OutputType),          INTENT(  OUT)  :: y           !< Initial system outputs (outputs are not calculated;
                                                                  !!   only the output mesh is initialized)
   TYPE(FWrap_MiscVarType),         INTENT(  OUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   REAL(DbKi),                      INTENT(IN   )  :: Interval    !< Coupling interval in seconds: the rate that
                                                                  !!   (1) Wrap_UpdateStates() is called in loose coupling &
                                                                  !!   (2) Wrap_UpdateDiscState() is called in tight coupling.
                                                                  !!   Input is the suggested time from the glue code;
                                                                  !!   Output is the actual coupling interval that will be used
                                                                  !!   by the glue code.
   TYPE(FWrap_InitOutputType),      INTENT(  OUT)  :: InitOut     !< Output for initialization routine
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   TYPE(FAST_ExternInitType)                       :: ExternInitData 
   
   INTEGER(IntKi)                                  :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                            :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                         :: RoutineName = 'FWrap_Init'

   
      ! Initialize variables

   ErrStat = ErrID_None
   ErrMsg  = ''


      ! Initialize the NWTC Subroutine Library

   !call NWTC_Init( )
   
      ! Display the module information

   if (InitInp%TurbNum == 1) call DispNVD( FWrap_Ver )



      ! Define initial system states here:

   x%Dummy          = 0.0_ReKi
   xd%Dummy         = 0.0_ReKi
   z%Dummy          = 0.0_ReKi
   OtherState%Dummy = 0.0_ReKi

      ! define optimization variables here:

      ! Define initial guess for the system inputs here:

   
      !.................
      ! Initialize an instance of FAST
      !................
      ExternInitData%Tmax = InitInp%TMax
      ExternInitData%SensorType = SensorType_None
      ExternInitData%LidRadialVel = .false.
      ExternInitData%NumSC2Ctrl = 0 ! "number of controller inputs [from supercontroller]"
      ExternInitData%NumCtrl2SC = 0 ! "number of controller outputs [to supercontroller]"
   
      ExternInitData%TurbineID = InitInp%TurbNum
      ExternInitData%TurbinePos = InitInp%p_ref_Turbine
      ExternInitData%FarmIntegration = .true.
      
      CALL FAST_InitializeAll_T( t_initial, InitInp%TurbNum, m%Turbine, ErrStat2, ErrMsg2, InitInp%FASTInFile, ExternInitData ) 
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) 
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
      
      !.................
      ! Define parameters here:
      !.................

      call SetParameters(InitInp, p, m%Turbine%p_FAST%dt, Interval, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) 
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
contains
   subroutine cleanup()
   
      call FAST_DestroyExternInitType(ExternInitData,ErrStat2,ErrMsg2) ! this doesn't actually do anything unless we add allocatable data later
      
   end subroutine cleanup

END SUBROUTINE FWrap_Init
!----------------------------------------------------------------------------------------------------------------------------------
! this routine sets the parameters for the FAST Wrapper module. It does not set p%n_FAST_low because we need to initialize FAST first.
subroutine SetParameters(InitInp, p, dt_FAST, InitInp_dt, ErrStat, ErrMsg)
   TYPE(FWrap_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(FWrap_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
   REAL(DbKi),                      INTENT(IN   )  :: dt_FAST     !< time step for FAST
   REAL(DbKi),                      INTENT(IN   )  :: InitInp_dt  !< time step for FAST.Farm
   
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   TYPE(FAST_ExternInitType)                       :: ExternInitData 
   
   INTEGER(IntKi)                                  :: i           
   INTEGER(IntKi)                                  :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                            :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                         :: RoutineName = 'FWrap_Init'
   
   
   p%p_ref_Turbine = InitInp%p_ref_Turbine  
   p%nr            = InitInp%nr              
   p%n_high_low    = InitInp%n_high_low  
   p%dt_high       = InitInp%dt_high
   p%nX_high       = InitInp%nX_high    
   p%nY_high       = InitInp%nY_high    
   p%nZ_high       = InitInp%nZ_high    

   call AllocAry(p%r, p%nr, 'p%r (radial discretization)', ErrStat2, ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call AllocAry(p%X_high, p%nX_high, 'p%X_high', ErrStat2, ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call AllocAry(p%Y_high, p%nY_high, 'p%Y_high', ErrStat2, ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call AllocAry(p%Z_high, p%nZ_high, 'p%Z_high', ErrStat2, ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

   if (ErrStat>=AbortErrLev) return
   
   do i=1,p%nr
      p%r(i) = i*InitInp%dr
   end do
   
   !BJJ: IT MIGHT be easier to just save the deltas so we can interpolate into these fields...
   do i=1,p%nX_high
      p%X_high(i) = InitInp%p_ref_high(1) + i*InitInp%dX_high
   end do

   do i=1,p%nY_high
      p%Y_high(i) = InitInp%p_ref_high(2) + i*InitInp%dY_high
   end do
   
   do i=1,p%nZ_high
      p%Z_high(i) = InitInp%p_ref_high(3) + i*InitInp%dZ_high
   end do
   
   ! this one will have to be set after we initialize FAST, because we need to know what the FAST time step is going to be.
   !p%n_FAST_low   
    
    
   IF ( EqualRealNos( dt_FAST, InitInp_dt ) ) THEN
      p%n_FAST_low = 1
   ELSE
      IF ( dt_FAST > InitInp_dt ) THEN
         ErrStat = ErrID_Fatal
         ErrMsg = "The FAST time step ("//TRIM(Num2LStr(dt_FAST))// &
                    " s) cannot be larger than FAST.Farm time step ("//TRIM(Num2LStr(InitInp_dt))//" s)."
      ELSE
            ! calculate the number of subcycles:
         p%n_FAST_low = NINT( InitInp_dt / dt_FAST )
            
            ! let's make sure the FAST DT is an exact integer divisor of the global (FAST.Farm) time step:
         IF ( .NOT. EqualRealNos( InitInp_dt, dt_FAST * p%n_FAST_low )  ) THEN
            ErrStat = ErrID_Fatal
            ErrMsg  = "The FAST module time step ("//TRIM(Num2LStr(dt_FAST))// &
                      " s) must be an integer divisor of the FAST.Farm time step ("//TRIM(Num2LStr(InitInp_dt))//" s)."
         END IF
            
      END IF
   END IF      

   
    
end subroutine SetParameters
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE FWrap_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(FWrap_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(FWrap_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
   TYPE(FWrap_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states
   TYPE(FWrap_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Discrete states
   TYPE(FWrap_ConstraintStateType), INTENT(INOUT)  :: z           !< Constraint states
   TYPE(FWrap_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states
   TYPE(FWrap_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   TYPE(FWrap_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   INTEGER(IntKi)                                  :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                            :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                         :: RoutineName = 'FWrap_End'

      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''


      !! Place any last minute operations or calculations here:

   CALL ExitThisProgram_T( m%Turbine, ErrID_None, .false. )   

      !! Close files here (but because of checkpoint-restart capability, it is not recommended to have files open during the simulation):


      !! Destroy the input data:

   call FWrap_DestroyInput( u, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


      !! Destroy the parameter data:

   call FWrap_DestroyParam( p, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      !! Destroy the state data:

   call FWrap_DestroyContState(   x,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call FWrap_DestroyDiscState(   xd,         ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call FWrap_DestroyConstrState( z,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call FWrap_DestroyOtherState(  OtherState, ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


      !! Destroy the output data:

   call FWrap_DestroyOutput( y, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

   
      !! Destroy the misc data:

   call FWrap_DestroyMisc( m, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)


END SUBROUTINE FWrap_End
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other 
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE FWrap_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, misc, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                       INTENT(IN   ) :: t               !< Current simulation time in seconds
   INTEGER(IntKi),                   INTENT(IN   ) :: n               !< Current step of the simulation: t = n*Interval
   TYPE(FWrap_InputType),            INTENT(INOUT) :: Inputs(:)       !< Inputs at InputTimes (output from this routine only 
                                                                      !!  because of record keeping in routines that copy meshes)
   REAL(DbKi),                       INTENT(IN   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   TYPE(FWrap_ParameterType),        INTENT(IN   ) :: p               !< Parameters
   TYPE(FWrap_ContinuousStateType),  INTENT(INOUT) :: x               !< Input: Continuous states at t;
                                                                      !!   Output: Continuous states at t + Interval
   TYPE(FWrap_DiscreteStateType),    INTENT(INOUT) :: xd              !< Input: Discrete states at t;
                                                                      !!   Output: Discrete states at t + Interval
   TYPE(FWrap_ConstraintStateType),  INTENT(INOUT) :: z               !< Input: Constraint states at t;
                                                                      !!   Output: Constraint states at t + Interval
   TYPE(FWrap_OtherStateType),       INTENT(INOUT) :: OtherState      !< Other states: Other states at t;
                                                                      !!   Output: Other states at t + Interval
   TYPE(FWrap_MiscVarType),          INTENT(INOUT) :: misc            !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                   INTENT(  OUT) :: ErrStat         !< Error status of the operation
   CHARACTER(*),                     INTENT(  OUT) :: ErrMsg          !< Error message if ErrStat /= ErrID_None

      ! Local variables

   TYPE(FWrap_ContinuousStateType)                 :: dxdt            ! Continuous state derivatives at t
   TYPE(FWrap_DiscreteStateType)                   :: xd_t            ! Discrete states at t (copy)
   TYPE(FWrap_ConstraintStateType)                 :: z_Residual      ! Residual of the constraint state functions (Z)
   TYPE(FWrap_InputType)                           :: u               ! Instantaneous inputs
   
   INTEGER(IntKi)                                  :: ErrStat2        ! local error status
   CHARACTER(ErrMsgLen)                            :: ErrMsg2         ! local error message
   CHARACTER(*), PARAMETER                         :: RoutineName = 'Wrap_UpdateStates'


      ! Initialize variables

   ErrStat   = ErrID_None           ! no error has occurred
   ErrMsg    = ''


   ! This subroutine contains an example of how the states could be updated. Developers will
   ! want to adjust the logic as necessary for their own situations.


   !!!
   !!!! Get the inputs at time t, based on the array of values sent by the glue code:
   !!!
   !!!! before calling ExtrapInterp routine, memory in u must be allocated; we can do that with a copy:
   !!!call FWrap_CopyInput( Inputs(1), u, MESH_NEWCOPY, ErrStat2, ErrMsg2 )
   !!!   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!   if ( ErrStat >= AbortErrLev ) then
   !!!      call cleanup()       ! to avoid memory leaks, we have to destroy the local variables that may have allocatable arrays or meshes
   !!!      return
   !!!   end if
   !!!
   !!!call FWrap_Input_ExtrapInterp( Inputs, InputTimes, u, t, ErrStat2, ErrMsg2 )  
   !!!   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!   if ( ErrStat >= AbortErrLev ) then
   !!!      call cleanup()
   !!!      return
   !!!   end if
   !!!
   !!!
   !!!
   !!!   ! Get first time derivatives of continuous states (dxdt):
   !!!
   !!!call FWrap_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, misc, dxdt, ErrStat2, ErrMsg2 )
   !!!   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!   if ( ErrStat >= AbortErrLev ) then
   !!!      call cleanup()
   !!!      return
   !!!   end if
   !!!
   !!!
   !!!   ! Update discrete states:
   !!!   !   Note that xd [discrete state] is changed in FWrap_UpdateDiscState() so xd will now contain values at t+Interval
   !!!   !   We'll first make a copy that contains xd at time t, which will be used in computing the constraint states
   !!!call FWrap_CopyDiscState( xd, xd_t, MESH_NEWCOPY, ErrStat2, ErrMsg2 )
   !!!   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!   if ( ErrStat >= AbortErrLev ) then
   !!!      call cleanup()
   !!!      return
   !!!   end if
   !!!
   !!!call FWrap_UpdateDiscState( t, n, u, p, x, xd, z, OtherState, misc, ErrStat2, ErrMsg2 )
   !!!   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!   if ( ErrStat >= AbortErrLev ) then
   !!!      call cleanup()
   !!!      return
   !!!   end if
   !!!
   !!!
   !!!   ! Solve for the constraint states (z) here:
   !!!
   !!!   ! Iterate until the value is within a given tolerance.
   !!!
   !!!! DO 
   !!!
   !!!   call FWrap_CalcConstrStateResidual( t, u, p, x, xd_t, z, OtherState, misc, Z_Residual, ErrStat2, ErrMsg2 )
   !!!      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   !!!      if ( ErrStat >= AbortErrLev ) then
   !!!         call cleanup()
   !!!         return
   !!!      end if
   !!!
   !!!   !  z =
   !!!
   !!!! END DO
   !!!
   !!!
   !!!
   !!!   ! Integrate (update) continuous states (x) here:
   !!!
   !!!!x = function of dxdt and x
   !!!
   !!!
   !!!   ! Destroy local variables before returning
   !!!call cleanup()


CONTAINS
   SUBROUTINE cleanup()
   ! note that this routine inherits all of the data in Wrap_UpdateStates


   CALL FWrap_DestroyInput(       u,          ErrStat2, ErrMsg2)
   CALL FWrap_DestroyConstrState( Z_Residual, ErrStat2, ErrMsg2)
   CALL FWrap_DestroyContState(   dxdt,       ErrStat2, ErrMsg2)
   CALL FWrap_DestroyDiscState(   xd_t,       ErrStat2, ErrMsg2) 

   END SUBROUTINE cleanup
END SUBROUTINE FWrap_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a routine for computing outputs, used in both loose and tight coupling.
SUBROUTINE FWrap_CalcOutput( t, u, p, x, xd, z, OtherState, y, misc, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(FWrap_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(FWrap_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(FWrap_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(FWrap_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(FWrap_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(FWrap_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(FWrap_MiscVarType),         INTENT(INOUT)  :: misc        !< Misc variables for optimization (not copied in glue code)
   TYPE(FWrap_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                  !!   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                  INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''


      ! Compute outputs here:


END SUBROUTINE FWrap_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------


END MODULE FASTWrapper
!**********************************************************************************************************************************
