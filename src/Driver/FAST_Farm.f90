!**********************************************************************************************************************************
!> ## FAST_Farm
!! The FAST_Farm, FAST_Farm_Subs, and FAST_Farm_Types modules make up a driver for the multi-turbine FAST.Farm code. 
!! FAST_Farms_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! FAST_Farm_Registry.txt file.
!!
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2016  Bonnie Jonkman, independent contributor
!! Copyright (C) 2016  National Renewable Energy Laboratory
!!
!!    This file is part of FAST_Farm.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
PROGRAM FAST_Farm

   USE FAST_Farm_Subs

   IMPLICIT NONE

   ! Local parameters:
REAL(DbKi),             PARAMETER     :: t_initial = 0.0_DbKi                    ! Initial time
   
   ! Other/Misc variables
INTEGER(IntKi)                        :: i_turb                                  ! current turbine number
INTEGER(IntKi)                        :: n_t_global                              ! simulation time step, loop counter for global simulation
INTEGER(IntKi)                        :: ErrStat                                 ! Error status
CHARACTER(ErrMsgLen)                  :: ErrMsg                                  ! Error message

   ! data for restart:
CHARACTER(1024)                       :: InputFileName                           ! Rootname of the checkpoint file
CHARACTER(1024)                       :: CheckpointRoot                          ! Rootname of the checkpoint file
CHARACTER(20)                         :: FlagArg                                 ! flag argument from command line
INTEGER(IntKi)                        :: Restart_step                            ! step to start on (for restart) 

! these should probably go in the FAST.Farm registry:
type(farm_parametertype)              :: p  
TYPE(FAST_TurbineType), allocatable   :: Turbine(:)                    ! Data for each turbine instance
logical                               :: IsInitialized    
TYPE(FAST_ExternInitType)             :: ExternInitData
 
!Note: Multiple entries in the same row implies that the operations can be done in parallel
!FAST.Farm Driver
!     Initialization:
!        Read-In Input File
!        Check Inputs and Set Parameters
!        CALL AWAE_Init, CALL_SC_Init
!        Transfer y_AWAE_Init to u_WD_Init, Transfer y_AWAE_Init to u_F_Init
!        CALL WD_Init, CALL F_Init
!        Open Output File
!        n=0
!        t=0
!     Initial Calculate Output:
!        CALL WD_CO, CALL SC_CO
!        Transfer y_WD to u_AWAE, Transfer y_CO to u_F
!        CALL AWEA_CO
!        Transfer y_AWAE to u_F and u_WD
!        CALL F_t0
!        Transfer y_F to u_SC and u_WD
!        Write Output to File
!     Time Increment:
!        Update States:
!           CALL WD_US, CALL SC_US, CALL F_Increment
!           n=n+1
!           t=t+dt
!        Calculate Output:
!           CALL WD_CO, CALL SC_CO
!           Transfer y_WD to u_AWAE, Transfer y_CO to u_F, Transfer y_F to u_SC and u_WD
!           CALL AWEA_CO
!           Transfer y_AWAE to u_F and u_WD
!           Write Output to File
!     End:
!        CALL SC_End
!        CALL F_End
!        CALL WD_End
!        CALL AWAE_End
!        Close Output File   
   

      ! Init NWTC_Library, display copyright and version information:
   CALL FAST_ProgStart( Farm_Ver )

   p%NumTurbines = 0
   IsInitialized = .false.
   
   InputFileName = "" ! make sure we don't think this is a "default" inputFileName if not specified on command line
   CALL CheckArgs( InputFileName, ErrStat, Flag=FlagArg )  ! if ErrStat /= ErrID_None, we'll ignore and deal with the problem when we try to read the input file
      
   IF ( TRIM(FlagArg) == 'RESTART' ) THEN ! Restart from checkpoint file
      CheckpointRoot = InputFileName
   !   CALL FAST_RestoreFromCheckpoint_Tary(t_initial, Restart_step, Turbine, CheckpointRoot, ErrStat, ErrMsg  )
   !      CALL CheckError( ErrStat, ErrMsg, 'during restore from checkpoint'  )           
   !   
   ELSE
      Restart_step = 0
      
      call Farm_Initialize( p, InputFileName, ErrStat, ErrMsg )
         CALL CheckError( ErrStat, ErrMsg, 'during driver initialization' )
      
      
      ALLOCATE(Turbine(p%NumTurbines),STAT=ErrStat)
         if (ErrStat /= 0) CALL CheckError( ErrID_Fatal, 'Could not allocate memory for FAST data', 'during driver initialization' )
            
      
      !.................
      ! Initialize each instance of FAST
      !................
      ExternInitData%Tmax = p%TMax
      ExternInitData%SensorType = SensorType_None
      ExternInitData%LidRadialVel = .false.
      ExternInitData%NumSC2Ctrl = 0 ! "number of controller inputs [from supercontroller]"
      ExternInitData%NumCtrl2SC = 0 ! "number of controller outputs [to supercontroller]"
      
      DO i_turb = 1,p%NumTurbines
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ! initialization
         !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         ExternInitData%TurbineID = i_turb
         ExternInitData%TurbinePos = p%WT_Position(:,i_turb)
                  
         CALL FAST_InitializeAll_T( t_initial, i_turb, Turbine(i_turb), ErrStat, ErrMsg, p%WT_FASTInFile(i_turb) )     ! bjj: we need to get the input files for each turbine (not necessarially the same one)
IsInitialized = .true.
         CALL CheckError( ErrStat, ErrMsg, 'during module initialization' )

!bjj: this will overwrite ProgName (in case of errors, this would say we're running FAST, not FAST.Farm)
         
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ! loose coupling
      !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      
         !...............................................................................................................................
         ! Initialization: (calculate outputs based on states at t=t_initial as well as guesses of inputs and constraint states)
         !...............................................................................................................................     
         CALL FAST_Solution0_T( Turbine(i_turb), ErrStat, ErrMsg )
         CALL CheckError( ErrStat, ErrMsg, 'during simulation initialization'  )
      
!make sure they all have the same time step!!!
         
      END DO
   END IF
   !
   !
   !   
   !!...............................................................................................................................
   !! Time Stepping:
   !!...............................................................................................................................         
   !
   !DO n_t_global = Restart_step, Turbine(1)%p_FAST%n_TMax_m1 
   !   
   !   ! bjj: we have to make sure the n_TMax_m1 and n_ChkptTime are the same for all turbines or have some different logic here
   !   
   !   
   !   ! write checkpoint file if requested
   !   IF (mod(n_t_global, Turbine(1)%p_FAST%n_ChkptTime) == 0 .AND. Restart_step /= n_t_global) then
   !      CheckpointRoot = TRIM(Turbine(1)%p_FAST%OutFileRoot)//'.'//TRIM(Num2LStr(n_t_global))
   !      
   !      CALL FAST_CreateCheckpoint_Tary(t_initial, n_t_global, Turbine, CheckpointRoot, ErrStat, ErrMsg)
   !         IF(ErrStat >= AbortErrLev .and. AbortErrLev >= ErrID_Severe) THEN
   !            ErrStat = MIN(ErrStat,ErrID_Severe) ! We don't need to stop simulation execution on this error
   !            ErrMsg = TRIM(ErrMsg)//Newline//'WARNING: Checkpoint file could not be generated. Simulation continuing.'
   !         END IF
   !         CALL CheckError( ErrStat, ErrMsg  )
   !   END IF
   !
   !   
   !   ! this takes data from n_t_global and gets values at n_t_global + 1
   !   DO i_turb = 1,NumTurbines
   !
   !      CALL FAST_Solution_T( t_initial, n_t_global, Turbine(i_turb), ErrStat, ErrMsg )
   !         CALL CheckError( ErrStat, ErrMsg  )
   !                                
   !         
   !         ! if we need to do linarization analysis, do it at this operating point (which is now n_t_global + 1) 
   !         ! put this at the end of the loop so that we can output linearization analysis at last OP if desired
   !      CALL FAST_Linearize_T(t_initial, n_t_global+1, Turbine(i_turb), ErrStat, ErrMsg)
   !         CALL CheckError( ErrStat, ErrMsg  )
   !         
   !   END DO
   !
   !   
   !   
   !END DO ! n_t_global
   !
   !
   !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   !  Write simulation times and stop
   !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   
   DO i_turb = 1,p%NumTurbines
      CALL ExitThisProgram_T( Turbine(i_turb), ErrID_None, .false. )
   END DO
   
   call Cleanup()
   call NormStop()
   
CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg,ErrLocMsg)
   ! This subroutine sets the error message and level and cleans up if the error is >= AbortErrLev
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN)           :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN)           :: Msg         ! The error message (ErrMsg)
      CHARACTER(*),   INTENT(IN), OPTIONAL :: ErrLocMsg   ! an optional message describing the location of the error

      CHARACTER(1024)                      :: SimMsg      
      integer(IntKi)                       :: i_turb2
      
      
      IF ( ErrID /= ErrID_None ) THEN
         CALL WrScr( NewLine//TRIM(Msg)//NewLine )
         IF ( ErrID >= AbortErrLev ) THEN
            
            IF (PRESENT(ErrLocMsg)) THEN
               SimMsg = ErrLocMsg
            ELSE
               ! make sure Turbine() is allocated!
               SimMsg = 'at simulation time '//TRIM(Num2LStr(Turbine(1)%m_FAST%t_global))//' of '//TRIM(Num2LStr(Turbine(1)%p_FAST%TMax))//' seconds'
            END IF
            
            if (IsInitialized) then
               DO i_turb2 = 1,p%NumTurbines
   !make sure we've initialized FAST before calling exit this program!!!!               
                     ! destroy any allocated arrays and/or pointers
                  CALL ExitThisProgram_T( Turbine(i_turb2), ErrID, .false., SimMsg ) 
               END DO
            end if
            
                        
            call Cleanup()
            call ProgAbort('', TrapErrors=.FALSE., TimeWait=3._ReKi )
            
         END IF
         
      END IF


   END SUBROUTINE CheckError   
   !............................................................................................................................... 
   SUBROUTINE Cleanup()
   
      if (allocated(Turbine)) deallocate(Turbine)
      
   END SUBROUTINE Cleanup
END PROGRAM FAST_Farm
!**********************************************************************************************************************************
